有感：学了好几天倒是明白了，设计模式就是一件事: 高内聚，低耦合。

设计模式:
1.iterator ---------------------------------------- (迭代器)
    设计的时候要松耦合(降低依赖性),使得部件之间相对独立,说白了就是不要体现具体数据类型，
而是用一种使用者不需要用关心的方式来访问或者迭代数据.
2.Adapter ----------------------------------------- (适配器)
    继承式:继承初始的类,然后原来的重写方法,这样可以在不改变原有类的情况下,增加新的功能。
    组合式:把初始的类作为一个属性,然后在新的类中调用初始类的方法,这样也可以在不改变原有
类的情况下,增加新的功能.
3.Template Method --------------------------------- (模板)
    父类实现部分肯定的方法和其他需要的抽象方法,将具体处理交给子类.这样子可以证核心算法
的一致性和减少代码的 冗余度.<子类实现抽象方法，不重写模板方法>
4.Factory Method ---------------------------------- (工厂)
    抽象的父类和父类决定实例的生成方式,但不决定所要生成的具体的类,子类自由的决定自己
要生成的类.<防止父类与其他具体类耦合>
5.Singleton --------------------------------------- (单例)
    私有化构造函数,到那时提供一个get它的静态方法,这样就可以保证这个实例的唯一性.
6.Prototype --------------------------------------- (原型)
    通过克隆来创建对象,而不是通过new来创建对象,这样可以减少对象的创建,提高性能.
7.Builder ----------------------------------------- (建造者)
    将复杂过程和具体的实现分离,使得相同的过程可以创建不同的实例,这样可以减少代码的冗余.
强调可扩展性和独立性.
8.Abstract Factory -------------------------------- (抽象工厂)
    /*太鸡儿难,我准备晚点再看*/
9.Bridge ------------------------------------------ (桥接)
    分离子类和父类的继承关系,使得子类可以独立的扩展,即可以进行子类功能的扩展和子类继承
的扩展,这样可以减少代码的冗余.
10.Strategy --------------------------------------- (策略)
    将算法的使用和算法的实现分离开来,使得算法的实现可以独立的变化,降低算法使用的耦合.
11.Composite -------------------------------------- (组合)
    对于某种类和构成其的子类,可以将其看成一个整体,利用递归的方法来处理这个整体.
12.Decorator -------------------------------------- (装饰)
    新建一个装饰性功能的类，在类中注入原有类的实例，然后在装饰类中调用原有类的方法，这样
就可以在不改变原有类的情况下，增加新的功能。
13.Visitor ---------------------------------------- (访问者)
    将数据结构和数据操作分离,使得操作集合可以独立的变化,而不会影响到数据结构.和迭代器
模式很像,但是迭代器模式是用来遍历数据的,而访问者模式是用来操作数据的.
14.Chain of Responsibility ------------------------ (责任链)
    本质上就是在不直接将请求在某个对象上处理,而是将可以处理这个请求的对象串起来,然后将
请求沿着这个链传递,直到有一个对象处理这个请求为止.
15.Facade ------------------------------------------ (门面)
    当API太多的时候,可以将其封装起来,对外提供一个简单的接口,这样可以减少API的使用难度.
16.Mediator ---------------------------------------- (中介者)
    对具有关联关系的对象进行封装,并不支持操作这些对象,而是通过中介者来操作这些对象.这样
可以减少对象之间的耦合.
17.Observer ---------------------------------------- (观察者)
    在类中引入一个"观察者",当某个事件发生时,通知观察者,观察者可以对这个事件进行处理，这样
子可以将类中的事件变化和类的业务逻辑分离开来.
18.Memento ----------------------------------------- (备忘录)
    额外写一个类来保存对象的状态,这样可以在不改变对象的情况下,保存对象的状态,以便在需要
的时候恢复对象的状态.
19.State -------------------------------------------- (状态)
    对于复杂可能性的类，可以将需求独立为多个状态，每个状态对应一个类，然后在类中引入一个
状态类的实例，当状态发生变化时，将状态类的实例替换为新的状态类的实例，这样可以将状态的
变化和类的业务逻辑分离开来。
20.Flyweight ---------------------------------------- (分享)
    对于某些后续可能会重复使用的对象，可以将其提前创建好，保存在一个池中，当需要使用时，
直接从池中取出，这样可以减少对象的创建和销毁的开销。
21.Proxy -------------------------------------------- (代理)
    增加一个代理类，代理类中注入原有类的实例，然后在代理类中调用原有类的方法，这样可以在
不改变原有类的情况下，增加新的功能。
22.Command ------------------------------------------ (命令)
    将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录
请求日志，以及支持可撤销的操作，和策略模式很像，但是策略模式是用来封装算法的，而命令模
式是用来封装请求的。
23.Interpreter -------------------------------------- (解释器)
    用来解释一种语言，比如正则表达式，SQL等。

面对对象设计原则
1.开闭原则
    对扩展开放，对修改关闭。即对于一个类，如果要增加新的功能，不要修改原有的代码，而是
增加新的代码。这样可以提高代码的可维护性。
2.里氏替换原则
    子类可以替换父类，即子类可以扩展父类的功能，但不能改变父类原有的功能。这样可以提高
代码的可扩展性。
3.依赖倒置原则
    高层模块不应该依赖低层模块，二者都应该依赖其抽象。抽象不应该依赖细节，细节应该依赖抽
象。这样可以提高代码的可维护性。
4.接口隔离原则
    使用多个专门的接口，而不使用单一的总接口。这样可以提高代码的可维护性。
5.迪米特法则
    一个对象应该对其他对象保持最少的了解。这样可以提高代码的可维护性。
6.合成复用原则
    尽量使用合成/聚合的方式，而不是使用继承。
7.单一职责原则
    一个类只负责一项职责。这样可以提高代码的可维护性。
8.最少知识原则
    一个类应该对自己需要耦合或调用的类知道得最少。这样可以提高代码的可维护性。