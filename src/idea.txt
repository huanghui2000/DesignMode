1.iterator ---------------------------------------- (迭代器)
    设计的时候要松耦合(降低依赖性),使得部件之间相对独立,说白了就是不要体现具体数据类型，
而是用一种使用者不需要用关心的方式来访问或者迭代数据.
2.Adapter ----------------------------------------- (适配器)
    继承式:继承初始的类,然后原来的重写方法,这样可以在不改变原有类的情况下,增加新的功能。
    组合式:把初始的类作为一个属性,然后在新的类中调用初始类的方法,这样也可以在不改变原有
类的情况下,增加新的功能.
3.Template Method --------------------------------- (模板)
    父类实现部分肯定的方法和其他需要的抽象方法,将具体处理交给子类.这样子可以证核心算法
的一致性和减少代码的 冗余度.<子类实现抽象方法，不重写模板方法>
4.Factory Method ---------------------------------- (工厂)
    抽象的父类和父类决定实例的生成方式,但不决定所要生成的具体的类,子类自由的决定自己
要生成的类.<防止父类与其他具体类耦合>
5.Singleton --------------------------------------- (单例)
    私有化构造函数,到那时提供一个get它的静态方法,这样就可以保证这个实例的唯一性.
6.Prototype --------------------------------------- (原型)
    通过克隆来创建对象,而不是通过new来创建对象,这样可以减少对象的创建,提高性能.
7.Builder ----------------------------------------- (建造者)
    将复杂过程和具体的实现分离,使得相同的过程可以创建不同的实例,这样可以减少代码的冗余.
强调可扩展性和独立性.
8.Abstract Factory -------------------------------- (抽象工厂)
    /*太鸡儿难,我准备晚点再看*/
9.Bridge ------------------------------------------ (桥接)
    分离子类和父类的继承关系,使得子类可以独立的扩展,即可以进行子类功能的扩展和子类继承
的扩展,这样可以减少代码的冗余.
10.Strategy --------------------------------------- (策略)
    将算法的使用和算法的实现分离开来,使得算法的实现可以独立的变化,降低算法使用的耦合.
11.Composite -------------------------------------- (组合)
    对于某种类和构成其的子类,可以将其看成一个整体,利用递归的方法来处理这个整体.
12.Decorator -------------------------------------- (装饰)
    新建一个装饰性功能的类，在类中注入原有类的实例，然后在装饰类中调用原有类的方法，这样
就可以在不改变原有类的情况下，增加新的功能。
13.Visitor ---------------------------------------- (访问者)
    将数据结构和数据操作分离,使得操作集合可以独立的变化,而不会影响到数据结构.和迭代器
模式很像,但是迭代器模式是用来遍历数据的,而访问者模式是用来操作数据的.
14.Chain of Responsibility ------------------------ (责任链)
    本质上就是在不直接将请求在某个对象上处理,而是将可以处理这个请求的对象串起来,然后将
请求沿着这个链传递,直到有一个对象处理这个请求为止.
15.Facade ------------------------------------------ (门面)
    当API太多的时候,可以将其封装起来,对外提供一个简单的接口,这样可以减少API的使用难度.
16.Mediator ---------------------------------------- (中介者)
    对具有关联关系的对象进行封装,并不支持操作这些对象,而是通过中介者来操作这些对象.这样
可以减少对象之间的耦合.
17.Observer ---------------------------------------- (观察者)
    当一个对象的状态发生改变的时候,所有依赖于它的对象都会得到通知,并自动更新.